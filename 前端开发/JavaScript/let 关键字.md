# 声明变量

关键字 let 在声明变量时的语法与 var 是一样的。

```jsx
let a = 100;
let b = "123";
let c = [];
let d = {};
```

# 关键字特性

## 无法重复声明

变量不能够重复声明，是为了防止变量被重复声明而产生修改，造成变量污染。

若通过关键字 `var` 声明的变量能够通过重复定义来改变其中的值：

```jsx
var a = 10;
var a = 20;
console.log(a); // Output: 20
```

这样的规则并不安全，当代码量过大时，可能会出现变量重复定义的问题，若重复定义了变量则会造成变量污染，可能出现问题。

通过 `let` 关键字则不能够重复定义。

```jsx
let b = 10;
let b = 20;
console.log(b);
```

上述代码在运行时会给出错误提示：

![[let 关键字 - Img1.png]]

当然变量污染只在两个重复变量处在一个作用域之内才会产生，下面就作用域的规则进行展开。

## 作用域

通过 `let` 关键字定义的变量只在代码块中有效。

在 ES6 中，通过 `let` 关键字定义的变量只能在作用域中有效，出了作用域将无法读取。

作用域包括全局作用域、函数作用域和 `eval` 作用域，如 `if-else` 、`while` 以及 `for` 等

```jsx
var c1 = 10;
let c2 = 10;
{
    var c1 = 20;
    let c2 = 20;
    console.log(c2); // 20
}
console.log(c1, c2); // 20 10
```

由于被 `{}` 包裹，其中的代码属于一个单独的作用域，使用 `var` 所定义的是全局变量，因此代码块作用域内部所定义的 `c1` 仍然会影响外层 `c1` 的值，因此输出的 `c1` 为 20；而使用 `let` 所定义的变量只会在当前作用域中生效，不会影响外层，所以在内部打印的 `c2` 值为 20，而外层打印的 `c2` 则为 10。

## 不存在变量提升

变量提升是指在定义变量的之前就引用变量会出现一个 undefined 而不是报出变量未定义的错误，这样不符合常规思维逻辑，这也是由于在执行代码前编译器会将所有变量先开辟内存空间，执行到赋值语句时再写入数据，因此使用 let 关键字定义变量时不存在变量提升的情况。

```jsx
console.log(a);    // undefined
var a = 123;

console.log(b);    // cannot access 'b' before initialization
let b = 456;
```

## 不影响作用域链

```jsx
{
    let a4 = 10;

    function show() {
        console.log(a4); // 10
    }

    show();
}
```