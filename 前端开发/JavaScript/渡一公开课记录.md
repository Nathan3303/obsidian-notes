# 浏览器事件循环

## 浏览器的进程模型

### 进程

每个程序拥有自己的内存空间，这块内存空间可以简单理解为进程。

每个程序至少拥有一个进程，进程之间相互独立，若要通信则需要双方同意。

进程被设计出来的目的就是为了数据隔离，一个进程一块独立的内存空间。

### 线程

线程是进程的子集，一个进程在开启后就会创建一个线程来运行代码，因此一个进程至少有一个线程，这样的线程就可以称为主线程。

如果进程需要同时执行多块代码，其中的主线程就可以启动更多的线程协助执行代码。所以一个进程可以包含多个线程。

## 浏览器的进程和线程

浏览器是一个多进程和多线程的应用程序。编写使用Cpp语言（Google）。目前谷歌浏览器的内核名称为blink。

浏览器中包含浏览器进程、网络进程以及渲染进程等。浏览器为了避免相互影响，为了减少连环崩溃的几率，当启动后会自动启动多个进程。

渲染进程的创建依据是浏览器标签页，每开启一个浏览器标签页就会创建一个渲染进程，这个渲染进程包含了多个线程。这些渲染进程相互独立、互不影响，当某一个标签页“崩溃”后，其他的标签页仍然能够正常浏览。渲染进程启动后，主线程会负责执行HTML、CSS以及JS代码。

![[渡一公开课记录 - Img1.png]]（浏览器任务管理器截图）

> 浏览器在未来的时间可能会改变这样的模式。若当标签页过多时所占用的内存会激增，因此使用每一个标签页就启动一个渲染进程的模式（Process per tab）会被修改为每一个站点就启动一个渲染进程（Process pre site）

## 渲染主线程如何工作

渲染主线程是浏览器中最繁忙的线程。需要处理的任务包括但不限于：

- 解析HTML
- 解析CSS
- 计算样式
- 布局
- 处理图层
- 每秒渲染60次
- 执行全局JS
- 执行微任务
- 执行交互任务
- 执行延时任务

> 思考题：为什么渲染进程不使用多个线程来处理这些事情。

### 主线程的任务调度

主线程通过任务队列来确定处理任务的时机。

![[Untitled 1.png]]

主线程的执行流程：

1. 渲染主线程在被创建后会进入一个无尽循环，即 `while(true)`。
2. 每一次循环会检查消息队列中是否有任务。
    1. 有：则取出任务进行执行处理。
    2. 没有：则进入休眠状态，等待新任务的排队
3. 其他所有线程（包括其他进程的线程）可以向消息队列中压入任务。当渲染主线程在休眠则会被唤醒，进入步骤2作出处理。

## 异步

在JS代码的执行过程中，会遇到一些无法立即处理的任务，比如：

- 计时器
- 网络通信
- 事件触发（用户交互）

若让渲染主线程等待这些任务的完成，则会导致一段时间的阻塞状态（若定时器定时一秒则阻塞主线程一秒），从而导致浏览器无法执行渲染任务，产生“卡死”现象。

![[Untitled 2.png]]

因此渲染主线程显然不能够如此工作，因此就产生了异步的工作模式。

当渲染主线程遇到了计时器、网络通信或事件绑定时会通知对应的线程进行监听或处理，此时主线程并不会进行阻塞，因为任务已经交给了其他线程进行处理，而是继续从消息队列中取出下一个任务进行执行处理。当各个线程监听到某些用户交互的动作或者是计时时间到达后会将回调函数包装为任务添加到消息队列，等待主线程的处理即可。

![[Untitled 3.png]]

这种异步的工作模式，使得页面的渲染主线程永不阻塞。

面试：如何理解 JS 的异步？
- JS 是一个单线程的语言，是运行在页面的渲染主线程中的，而这样的渲染主线程只有一个。
- 而渲染主线程承担着很多的工作，渲染页面和执行 JS 都在其中。若使用同步的方式，则极有可能产生主线程的阻塞，从而导致后续的任务需要等待阻塞结束后才能够被执行，这样一来，一方面会导致主线程空转浪费资源，另一方面也会导致用户体验极大地下降，因此通过异步的方式来解决这样的阻塞问题。
- 异步的工作模式可以简单的描述为主线程不等待计时任务或者网络通信任务明确完成后采取执行下一个任务，而是通知对应的线程执行对应的任务后就转而执行下一个任务，当这些线程执行完成后，将指定的回调函数包装成任务加入到消息队列排队，等待渲染主进程的处理，消除主线程的阻塞。

渲染主线程在执行某个任务时可能遇到需要新增的任务，如修改了某个DOM的结构，会产生一个渲染任务，这个渲染任务会被加入到消息队列中进行排队，从而使页面更新；也可能是执行了一个Promise任务，其中的then方法会被添加在消息队列中排队。

### 任务优先级

任务没有优先级，而消息队列有优先级，因此消息队列不止一个。

任务被划分为多个类型，同一个类型的任务必须在一个队列中，不同类型的任务可以被分属为不同的队列。在一次事件循环中，渲染主线程（浏览器）会根据实际情况从不同的队列中取出任务进行执行处理。

浏览器必须准备好一个微队列（microtask queue），微队列中的任务必须优先于其他所有任务。

在目前的chrome中，至少包含了三个队列：

1. 延时队列：用于存放计时器到达后的回调任务（中）
2. 交互队列：用于存放用户交互的事件回调任务（高）
3. 微队列：存放由 Promise、MutationObserver 等所定义的回调任务（最高）

具体流程：计时器 → 交互事件 → Promise/MutationObserver

> 队列执行流程试题：
> 
> 
> ```jsx
> function fn() {
> 	console.log(1);
> 	Promise.resolve().then(() => {
> 		console.log(2);
> 	})
> }
> 
> setTimeout(() => {
> 	console.log(3);
> 	Promise.resolve().then(fn);
> }, 0)
> 
> Promise.resolve().then(() => {
> 	console.log(4);
> })
> 
> console.log(5);
> 
> // Output:
> // 5
> // 4
> // 3
> // 1
> // 2
> ```
> 

> 面试：阐述JS的事件循环
事件循环又称为消息循环，是浏览器渲染主线程的工作方式。
主线程在创建后会进入无尽循环，每次循环从消息队列中取出最旧的任务进行执行处理，而其他线程只需要将回调包装为任务添加到队列中即可。
不同的任务有不同的类型标记，不同类型的任务可以被添加到同一个队列，但不能够同时处在多个队列中，队列不止一个、不同的队列拥有不同的优先级，主线程会在每一次循环中按照队列优先级进行任务的读取和执行。
> 

> 面试：JS 能做到计时器精确计时吗？为什么？
JS 不能做到计时器精确计时。
4. 由于浏览器最终是调用操作系统的时间，由于操作系统本身可能存在偏差，这样的偏差也被带到了浏览器中。
5. 当计时器的嵌套等级超过五层，则后续的层级中的计时时间的最小值会被设置为 4ms。
6. 并且收到事件循环的影响，计时器的回调函数的触发只能在比延时队列优先级高的队列中的所有任务处理完毕后才能够运行，因此这样的工作模式也会带有一定的计时偏差。
> 

总结：

- 单线程是一步产生的原因
- 事件循环是异步的实现方式，解决阻塞的问题。
- 微队列必须比其他队列优先级更高，其中的任务必须被优先处理

# 浏览器渲染原理

## 浏览器渲染

通过一个链接地址拿到的是一个集合了 HTML、CSS 和 JS 代码的字符串文件。浏览器通过解析这些字符串信息，解析为一个个元素对象，计算这些对象的位置、颜色等属性，通过显卡渲染到页面上。

### 渲染时间点

![[Untitled 4.png]]

浏览器主进程通知网络线程进行通信，获取到HTML文件后，将渲染任务加入到消息队列，当显然主线程空闲后取出渲染任务进行渲染，刷新页面。

### 渲染基本流程

![[Untitled 5.png]]

每个阶段都有明确的输入和输出，前一个阶段的输出会成为下一个阶段的输入。

### 解析HTML - Parse HTML

这一步会将 HTML 转换为两颗树（DOM 树、CSSOM 树）

DOM：document object model（JS 的 dom 节点即为 C++的 dom 节点的包装）

CSSOM：CSS object model（通过 document.styleSheet 修改样式表）

HTML样式分类：

- `<style>` 内部样式表
- `<link ...>` 外部样式表
- `<div style="...">` 内联样式
- 浏览器默认样式表

![[Untitled 6.png]]

![[Untitled 7.png]]

页面渲染主线程在解析 HTML 时会通知预解析线程对 CSS 进行下载和处理，因此在主线程遇到 Link 这一类外部文件时会跳过解析，使得 HTML 和 CSS 同步解析，提高解析速度。但 CSSOM 结构依然会在主线程中生成。

这也是 CSS 的解析不会阻塞 HTML 解析的原因，因为 CSS 和 HTML 分别在不同的线程上进行处理，最后再合并到主线程上。

![[Untitled 8.png]]

页面渲染主线程在解析 HTML 时遇到 `<script>` 这种外部 JS 引入时，会暂停当前的工作，交给预解析线程进行 JS 的下载，等待 JS 文件的下载完成，并执行 JS，直到执行完成后在解析 HTML。

JS 会阻塞 HTML 解析的原因是因为 JS 中的代码有可能会产生对之前元素的影响，如修改 DOM 树，修改 CSSOM 树等操作。

![[Untitled 9.png]]

### 样式计算 - Re-calculate style

主线程会遍历得到的DOM树，依次为树中的每个节点计算出它的最终样式（Computed Style）。

在这一过程中，很多预设值会变为绝对值，比如red会变为rgb(255,0,0)；相对单位会变成绝对单位，比如em会变成px。

Computed Style是所有CSS样式的集合，没有被定义的样式属性会被设置为（浏览器）预设值。

CSS的两个重点内容：
1. css 属性值的计算过程：层叠、继承承
2. 视觉格式化模型：盒模型、包含块、流式布局、格式布局、BFC

### 布局 - layout

根据样式计算后的DOM树通过一系列操作生成一个Layout树，Layout树包括元素的尺寸和位置等信息，比如尺寸的宽高、位置的相对目标（相对谁定位）。

包含块：宽高和位置的计算对象的统称。

设置为display:none;的DOM节点不会生成对应的节点在Layout树上，因为他没有几何信息。

::after和::before在DOM树上没有对应的节点，但会在Layout树上生成对应节点。

没有标签的文本内容会被包含在一个行盒中，在Layout树上

文本内容必定会被包含在行盒中，且行盒和块盒不能相邻。

![[Untitled 10.png]]

### 分层 - Layer

分层阶段会对上一阶段的结果，也就是Layout树，进行分层操作，这样的操作是解决重绘的性能问题。对需要改变的结构进行一个分层，当结构变化是只需要重绘这一个层次即可，不需要重新绘制整个页面，以达到优化的目的。分层是依据根据某一些操作，而不是每一个结构都分一层，这样的操作通常是对堆叠上下文的相关属性的操作，如zIndex等。

### 绘制 - Paint

绘制阶段是根据分层结构生成绘制指令，绘制指令大致为：移动绘制指针，绘制什么等。这些绘制指令也会根据层级的不同进行划分。

### 分块 - Tiling

分块会将整个页面分成多个小块，根据视口位置，会优先绘制视口范围的块，以提高用户体验。

分块操作会启动多个分块线程，在绘制时

完成绘制后，主线程将每个图层的回执信息提交给合成线程，剩余工作将有合成线程完成。

合成线程首先对每个图层进行分块，将其划分为更多的小区域

合成线程会从线程池中拿取多个

### 光栅化 - Raster

光栅化是将每个块变成位图。

优先处理靠近视口的块

光栅化阶段会使用到GPU加速。

![[Untitled 11.png]]

### 画 - Draw

合成线程计算出每个位图在屏幕上的位置，交给 GPU 进行最终呈现。

![[Untitled 12.png]]

### 完整过程

![[Untitled 13.png]]

